/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    : main.c
  * @brief   : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2024 MingZe.
  * All rights reserved.</center></h2>
  *
  * This is a simple program demonstrating signal handling in C.
  * It sets up a signal handler to catch SIGINT signals (typically generated by pressing Ctrl+C).
  * After blocking the SIGINT signal temporarily, it sleeps for 5 seconds and then unblocks the signal.
  * Finally, it enters an infinite loop to keep the program running.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
#include <stdio.h>
#include <signal.h>
#include <unistd.h>


void handle(int si);
   
int main() {
 struct sigaction act,old_act;
    act.sa_handler = handle;    // 设置信号处理函数为 handle
    act.sa_flags = 0;
    // 清空信号屏蔽集
    sigemptyset(&act.sa_mask);  
    // 捕获 SIGINT 信号，并指定处理函数为 handle,当信号发生时，传递给内核,内核调用handle函数
    sigaction(SIGINT, &act, NULL); 

    /* 初始化信号屏蔽集 */   
    sigset_t mask,mask1;
    sigemptyset(&mask);
    sigemptyset(&mask1);
    sigaddset(&mask, SIGINT);   // 将 SIGINT 信号添加到信号屏蔽集,注意这里只是添加到信号屏蔽集，并没有屏蔽信号，要对这个信号屏蔽集进行应用，例如sigprocmask

    pause();

    while(1)
    {
      sigprocmask(SIG_BLOCK, &mask, NULL);  // 阻塞 SIGINT 信号,之后处理
      printf("hello\n");
      sleep(5);
      printf("world\n");


      //sigsuspend(&mask1);//暂时改变信号掩码为mask，并挂起等待未被mask1屏蔽的信号

      /*sigprocmask解除对 SIGINT 信号的阻塞，后立刻响应SIGINT信号，pause将不会被触发*/
      // sigprocmask(SIG_UNBLOCK, &mask, NULL); 
      // pause();
    }

    return 0; 
}



void handle(int si) {
    printf("get sig:%d\n", si);
}
/*
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int,siginfo_t*,void)
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}*/



/*保存当前进程的信号掩码（即当前哪些信号被阻止）。
将mask参数指定的信号掩码应用到当前进程中（即暂时改变信号掩码为mask。）
进程挂起，等待一个未被mask屏蔽的信号。
当一个未被屏蔽的信号到达时，sigsuspend函数返回，同时恢复原先的信号掩码。
*/